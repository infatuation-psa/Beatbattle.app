

// UserTrophies - Retrieves user's victories and returns a page containing them.
func UserTrophies(c echo.Context) error {
	// Set the request to close automatically.
	c.Request().Header.Set("Connection", "close")
	c.Request().Close = true
	// Check if user is authenticated and retrieve any groups that they have invite privileges to.
	// This is for the invite functionality.
	userID := 0
	user := User{}
	me := GetUser(c, false)

	toast := GetToast(c)
	ads := GetAdvertisements()
	title := ""

	// Is this a request to check their own account?
	if c.Request().URL.String() == "/me/submissions" {
		userID = me.ID
		user = GetUserDB(userID)
		title = "My"
	} else {
		userID, _ = strconv.Atoi(c.Param("id"))
		user = GetUserDB(userID)
		title = user.Name + "'s"
	}

	submission := Beat{}
	entries := []Beat{}

	query := `
			SELECT beats.url, beats.votes, beats.voted, challenges.id, challenges.status, challenges.title
			FROM beats
			LEFT JOIN challenges on challenges.id=beats.challenge_id
			WHERE beats.user_id=?
			GROUP BY 1
			ORDER BY beats.id DESC`

	rows, err := dbRead.Query(query, userID)
	if err != nil {
		SetToast(c, "502")
		return c.Redirect(302, "/")
	}
	defer rows.Close()

	for rows.Next() {
		submission = Beat{}
		err = rows.Scan(&submission.URL, &submission.Votes, &submission.Voted, &submission.ChallengeID, &submission.Status, &submission.Battle)
		if err != nil {
			SetToast(c, "502")
			return c.Redirect(302, "/")
		}

		submission.Status = strings.Title(submission.Status)
		if !submission.Voted {
			submission.Status = `<span class="tooltipped" data-tooltip="Did Not Vote">` + submission.Status + ` <span style="color: #0D88FF;">(*)</span></span>`
		}

		u, _ := url.Parse(submission.URL)
		urlSplit := strings.Split(u.RequestURI(), "/")

		if len(urlSplit) >= 4 {
			secretURL := urlSplit[3]
			if strings.Contains(secretURL, "s-") {
				submission.URL = `<iframe height='20' scrolling='no' frameborder='no' allow='autoplay' show_user='false' src='https://w.soundcloud.com/player/?url=https://soundcloud.com/` + urlSplit[1] + "/" + urlSplit[2] + `?secret_token=` + urlSplit[3] + `&color=%23ff5500&inverse=false&autoplay=true&show_user=false'></iframe>`
			} else {
				submission.URL = `<iframe height='20' scrolling='no' frameborder='no' allow='autoplay' src='https://w.soundcloud.com/player/?url=` + submission.URL + `&color=%23ff5500&inverse=false&autoplay=true&show_user=false'></iframe>`
			}
		} else {
			submission.URL = `<iframe height='20' scrolling='no' frameborder='no' allow='autoplay' src='https://w.soundcloud.com/player/?url=` + submission.URL + `&color=%23ff5500&inverse=false&autoplay=true&show_user=false'></iframe>`
		}

		entries = append(entries, submission)
	}
	// Reference: http://go-database-sql.org/errors.html - I'm not really sure if this does anything positive lmao.
	if err = rows.Err(); err != nil {
		log.Println(err)
	}
	if err = rows.Close(); err != nil {
		log.Println(err)
	}

	submissionsJSON, err := json.Marshal(entries)
	if err != nil {
		SetToast(c, "502")
		return c.Redirect(302, "/")
	}

	m := map[string]interface{}{
		"Title":      title + " Submissions",
		"Page":       "submissions",
		"Beats":      string(submissionsJSON),
		"Me":         me,
		"User":       user,
		"Toast":      toast,
		"Tag":        policy.Sanitize(c.Param("tag")),
		"Ads":        ads,
	}

	return c.Render(302, "UserSubmissions", m)
}